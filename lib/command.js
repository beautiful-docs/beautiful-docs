// Generated by CoffeeScript 1.9.0
(function() {
  var S, arg, argv, bfdocs, destDir, fs, generateIndex, generateManifest, handleManifest, loadManifests, lock, manifests, options, parts, path, startServer, switches, v, _, _i, _len, _ref;

  bfdocs = require('..');

  fs = require('fs');

  path = require('path');

  _ = require('underscore');

  S = require('string');

  switches = {
    help: ['--help', 'Display the help information'],
    server: ['--server', 'Create an HTTP server to access the generated documentation'],
    port: ['--port', 'The port on which the HTTP server shoud listen'],
    watch: ['--watch', 'Watch files for modifications and reload them automatically'],
    manifestsOnly: ['--manifests-only', 'Do not treat the last argument as the output dir but also as a manifest'],
    title: ['--title', 'Title of the index page'],
    baseUrl: ['--base-url', 'Base url of all links'],
    indexOnly: ['--index-only', 'Only generate the index file. The last argument should be the filename of the index'],
    version: ['--version', 'Display the installed version of beautiful-docs'],
    theme: ['--theme', 'Name of bundled theme or path to custom theme']
  };

  argv = [];

  options = {
    help: false,
    server: false,
    port: 8080,
    watch: false,
    manifestsOnly: false,
    title: 'Beautiful Docs',
    baseUrl: '',
    indexOnly: false,
    version: false,
    theme: 'default'
  };

  _ref = process.argv.slice(2);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    arg = _ref[_i];
    if (arg.substr(0, 2) === '--') {
      parts = arg.split('=');
      v = parts[1] || true;
      if (v === 'false') {
        v = false;
      }
      _.forEach(switches, function(sw, name) {
        if (sw[0] === parts[0]) {
          return options[name] = v;
        }
      });
    } else {
      argv.push(arg);
    }
  }

  if (options.help) {
    console.log("Usage: bfdocs [options] [/path/to/manifest.json] [/path/to/output/dir]\n");
    console.log("Available options:");
    _.forEach(switches, function(sw) {
      return console.log("  " + sw[0] + "\t\t\t" + sw[1]);
    });
    process.exit(0);
  }

  if (options.version) {
    console.log(bfdocs.version);
    process.exit(0);
  }

  destDir = options.indexOnly ? './index.html' : './out';

  if (argv.length === 0) {
    argv.push('.');
  } else if (argv.length > 1 && !options.manifestsOnly) {
    destDir = _.last(argv);
    argv = _.initial(argv);
  }

  lock = argv.length;

  manifests = [];

  generateManifest = function(manifest, callback) {
    var dest, opts;
    if (callback == null) {
      callback = null;
    }
    dest = destDir;
    opts = _.extend({}, options);
    if (argv.length > 1) {
      dest = path.join(destDir, manifest.slug);
      _.extend(opts, {
        baseUrl: (options.baseUrl !== '' ? S(options.baseUrl).ensureRight('/').s + manifest.slug : manifest.slug)
      });
    }
    return bfdocs.generate(manifest, dest, opts, callback);
  };

  generateIndex = function(filename, callback) {
    if (callback == null) {
      callback = null;
    }
    return bfdocs.generateIndex(options.title || 'Beautiful docs', manifests, filename, options, callback);
  };

  startServer = function(err) {
    if (options.server) {
      console.log("Starting server on port " + options.port);
      return bfdocs.serveStaticDir(destDir, options.port);
    } else if (options.watch) {
      console.log("Press Ctrl+C to quit");
      return setInterval((function() {
        return 1;
      }), 100);
    }
  };

  handleManifest = function(err, manifest) {
    var indexFilename;
    if (err) {
      console.log("An error occured while opening a manifest: " + err);
      return;
    }
    manifests.push(manifest);
    indexFilename = path.join(destDir, 'index.html');
    if (options.indexOnly) {
      if (--lock === 0) {
        generateIndex(indexFilename, startServer);
      }
      return;
    }
    return generateManifest(manifest, function(err) {
      if (err) {
        lock--;
        console.log("An error occured while generating a manifest: " + err);
        return;
      }
      if (options.watch) {
        manifest.watch(function() {
          console.log("Changes detected to '" + manifest.uri + "'");
          return generateManifest(manifest, function(err) {
            if (err) {
              return;
            }
            if (argv.length > 1) {
              return generateIndex(indexFilename);
            }
          });
        });
      }
      if (--lock === 0) {
        if (argv.length > 1) {
          return generateIndex(indexFilename, startServer);
        } else {
          return startServer();
        }
      }
    });
  };

  loadManifests = function() {
    var filename, _j, _len1, _results;
    _results = [];
    for (_j = 0, _len1 = argv.length; _j < _len1; _j++) {
      filename = argv[_j];
      if (fs.statSync(filename).isDirectory()) {
        console.log("Generating documentation from directory '" + filename + "'");
        _results.push(bfdocs.createManifestFromDir(filename, handleManifest));
      } else {
        console.log("Generating documentation from manifest '" + filename + "'");
        _results.push(bfdocs.open(filename, handleManifest));
      }
    }
    return _results;
  };

  if (options.indexOnly) {
    loadManifests();
  } else {
    fs.exists(destDir, function(exists) {
      if (!exists) {
        return fs.mkdir(destDir, function(err) {
          if (err) {
            return console.log("An error occured while creating '" + destDir + "': " + err);
          }
          return loadManifests();
        });
      } else {
        return loadManifests();
      }
    });
  }

}).call(this);

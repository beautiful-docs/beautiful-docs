// Generated by CoffeeScript 2.5.1
(function() {
  var Generator, S, _, async, coffee, eco, fs, less, path, util, yaml;

  eco = require('eco');

  path = require('path');

  fs = require('fs');

  util = require('util');

  _ = require('underscore');

  less = require('less');

  coffee = require('coffee-script');

  async = require('async');

  S = require('string');

  yaml = require('js-yaml');

  Generator = class Generator {
    // Generates the html files

    // options - An object with options for the generation and the templates
    constructor(options) {
      this.options = _.extend({
        theme: 'default',
        compileThemeFiles: true,
        templates: {
          layout: '_layout.html',
          page: '_page.html',
          manifests: '_manifests.html'
        },
        defaultCategory: "All projects",
        baseUrl: ''
      }, options);
      if (this.options.baseUrl !== '') {
        this.options.baseUrl = S(this.options.baseUrl).ensureRight('/').s;
      }
    }

    // Public: Returns the pathname of a file inside the theme folder

    // filename   - Filename of the file
    // callback
    getThemeFilename(filename, callback) {
      return fs.exists(this.options.theme, (exists) => {
        if (exists) {
          filename = path.join(this.options.theme, filename);
        } else {
          filename = path.join(__dirname, "themes", this.options.theme, filename);
        }
        return fs.exists(filename, function(exists) {
          return callback(filename, exists);
        });
      });
    }

    // Public: Renders a template from a string

    // data      - Template string
    // vars      - An object that will become this in the template
    renderString(data, vars) {
      return eco.render(data.toString(), _.extend({}, this.options, vars));
    }

    fileHasHeader(filename, callback) {
      return fs.readFile(filename, function(err, data) {
        var lines;
        if (err) {
          return callback(err);
        }
        lines = S(data).lines();
        return callback(lines[0] === '---');
      });
    }

    parseFileHeader(data) {
      var header, j, len, line, lines;
      lines = S(data).lines();
      if (lines[0] !== '---') {
        return [false, data];
      }
      lines.shift();
      header = [];
      for (j = 0, len = lines.length; j < len; j++) {
        line = lines[j];
        if (line === '---') {
          break;
        } else {
          header.push(line);
        }
      }
      data = lines.slice(header.length + 1).join("\n");
      header = header.length > 0 ? yaml.safeLoad(header.join("\n")) : {};
      return [header, data];
    }

    render(filename, vars, callback) {
      return fs.readFile(filename, (err, data) => {
        var content, header;
        if (err) {
          return callback(err);
        }
        [header, data] = this.parseFileHeader(data);
        vars = _.extend({}, vars, header);
        vars["include"] = (relfilename) => {
          return this.renderString(fs.readFileSync(path.join(path.dirname(filename), relfilename)), vars);
        };
        content = this.renderString(data, vars);
        if (header.layout) {
          return this.getThemeFilename(header.layout, (tplname, exists) => {
            if (!exists) {
              return cb("Missing layout: " + tplname);
            }
            return this.render(tplname, _.extend({}, vars, {
              content: content
            }), callback);
          });
        } else {
          return callback(null, content);
        }
      });
    }

    // Public: Equivalent of mkdir -p

    // dir       - Directory to create
    // callback  - A function that will be called once the path is created
    mkdir(dir, callback) {
      return fs.exists(dir, (exists) => {
        if (exists) {
          return callback(null);
        }
        return this.mkdir(path.dirname(dir), function(err) {
          if (err) {
            return callback(err);
          }
          return fs.mkdir(dir, callback);
        });
      });
    }

    // Public: Copies a file from src to dest

    // src       - Source filename
    // dest      - Destination filename
    // callback  - A function that will be called once the file is copied
    copy(src, dest, callback) {
      return this.mkdir(path.dirname(dest), function(err) {
        var ins, outs;
        if (err) {
          return callback(err);
        }
        ins = fs.createReadStream(src);
        ins.on('error', callback);
        outs = fs.createWriteStream(dest);
        outs.on('error', callback);
        ins.on('end', callback);
        return ins.pipe(outs);
      });
    }

    // Public: Generates an index file containing a list of all manifests
    // ordered by category. Default category is "All Projects"

    // title         - Title of the page
    // manifests     - An array of Manifest objects
    // filename      - The filename of the generated file
    // callback      - A function that will be called once the file is created
    generateIndex(title, manifests, filename, callback = null) {
      var categories, j, len, m, name, vars;
      categories = {};
      for (j = 0, len = manifests.length; j < len; j++) {
        m = manifests[j];
        name = m.category || this.options.defaultCategory;
        if (!categories[name]) {
          categories[name] = [];
        }
        categories[name].push(m);
      }
      vars = {
        title: title,
        categories: categories
      };
      return this.getThemeFilename('_manifests.html', (tplname, exists) => {
        if (!exists) {
          return callback("Missing template: " + tplname);
        }
        return this.render(tplname, vars, (err, content) => {
          if (err) {
            if (callback) {
              callback(err);
            }
            return;
          }
          return this.mkdir(path.dirname(filename), function(err) {
            if (err) {
              if (callback) {
                callback(err);
              }
              return;
            }
            return fs.writeFile(filename, content, callback);
          });
        });
      });
    }

    // Public: Generates all html files associated to a manifest. Also copies
    // relative assets references in the manifest files

    // manifest  : A Manifest object
    // destDir   : Directory where to save all the generated files
    // callback  : A function that will be called once all files are generated
    generate(manifest, destDir, callback = null) {
      var allContent, copyStylesheet, copyThemeFiles, renderAll, renderFile, renderFiles, renderHomepage;
      allContent = '';
      renderFile = (file, filename, cb) => {
        var copyAsset, vars;
        copyAsset = (a, c) => {
          return this.copy(file.makeRelativeUri(a), path.join(destDir, a), c);
        };
        vars = {
          manifest: manifest,
          content: file.html
        };
        return this.getThemeFilename('_page.html', (tplname, exists) => {
          if (!exists) {
            return cb("Missing template: " + tplname);
          }
          return this.render(tplname, vars, function(err, content) {
            if (err) {
              return cb(err);
            }
            return fs.writeFile(path.join(destDir, filename + '.html'), content, function(err) {
              if (err) {
                return cb(err);
              }
              return async.forEach(file.assets, copyAsset, cb);
            });
          });
        });
      };
      renderFiles = (cb) => {
        var file, i, lock, ref, results;
        lock = manifest.files.length;
        ref = manifest.files;
        results = [];
        for (i in ref) {
          file = ref[i];
          if (manifest.ignoreFirstFileForToc && i === 0) {
            continue;
          }
          allContent += file.html + "\n";
          results.push(renderFile(file, file.slug, function() {
            if (--lock === 0) {
              return cb();
            }
          }));
        }
        return results;
      };
      renderHomepage = (cb) => {
        return renderFile(manifest.files[0], 'index', cb);
      };
      renderAll = (cb) => {
        return this.getThemeFilename('_page.html', (tplname, exists) => {
          return this.render(tplname, {
            manifest: manifest,
            content: allContent
          }, function(err, content) {
            if (err) {
              return cb(err);
            }
            return fs.writeFile(path.join(destDir, 'all.html'), content, cb);
          });
        });
      };
      copyStylesheet = (cb) => {
        var filename;
        if (manifest.options.css == null) {
          return cb();
        }
        filename = manifest.options.css;
        if (filename.substr(0, 1) !== '/' && !filename.match(/^(https?):\/\//)) {
          return this.copy(manifest.makeRelativeUri(filename), path.join(destDir, filename), cb);
        } else {
          return cb();
        }
      };
      copyThemeFiles = (cb) => {
        return this.getThemeFilename('.', (srcDir, exists) => {
          if (!exists) {
            return cb();
          }
          return this.copyFiles(srcDir, destDir, this.options.compileThemeFiles, {
            manifest: manifest
          }, cb);
        });
      };
      return async.series([
        ((cb) => {
          return this.mkdir(destDir,
        cb);
        }),
        renderHomepage,
        renderFiles,
        renderAll,
        copyStylesheet,
        copyThemeFiles
      ], function(err) {
        if (callback) {
          return callback(err);
        }
      });
    }

    // Public: Copies all files from srcDir to destDir. 
    // Eventually transforms less and coffee files and render html files

    // srcDir                : Where the original assets are located
    // destDir               : Where to copy the assets to
    // compileFiles          : Whether to transform less and coffee files and render html files
    // callback              : A function that will be called once all files are copied
    copyFiles(srcDir, destDir, compileFiles = true, tplVars = {}, callback = null) {
      var compileFile, copyFile, handleFile, handleFiles;
      compileFile = (data, filename, cb) => {
        var target;
        if (compileFiles && path.extname(filename) === '.less') {
          target = path.basename(filename, path.extname(filename)) + '.css';
          return less.render(data.toString(), function(err, output) {
            return cb(err, target, output);
          });
        } else if (compileFiles && path.extname(filename) === '.coffee') {
          target = path.basename(filename, path.extname(filename)) + '.js';
          return cb(null, target, coffee.compile(data.toString()));
        } else {
          return cb(null, filename, data);
        }
      };
      copyFile = (pathname, filename, cb) => {
        return fs.readFile(pathname, (err, data) => {
          if (err) {
            return cb(err);
          }
          return compileFile(data, filename, function(err, filename, content) {
            if (err) {
              return cb(err);
            }
            return fs.writeFile(path.join(destDir, filename), content, cb);
          });
        });
      };
      handleFile = (filename, cb) => {
        var pathname;
        pathname = path.join(srcDir, filename);
        return fs.stat(pathname, (err, stat) => {
          if (err) {
            return cb(err);
          }
          if (stat.isDirectory()) {
            return this.mkdir(path.join(destDir, filename), (err) => {
              if (err) {
                return cb(err);
              }
              return this.copyFiles(pathname, path.join(destDir, filename), compileFiles, tplVars, cb);
            });
          } else if (!S(filename).startsWith('_')) {
            return this.fileHasHeader(pathname, (hasHeader) => {
              if (hasHeader) {
                return this.render(pathname, tplVars, function(err, content) {
                  return compileFile(content, filename, function(err, filename, content) {
                    if (err) {
                      return cb(err);
                    }
                    return fs.writeFile(path.join(destDir, filename), content, cb);
                  });
                });
              } else {
                return copyFile(pathname, filename, cb);
              }
            });
          } else {
            return cb();
          }
        });
      };
      handleFiles = (err, files, cb) => {
        if (err) {
          return cb(err);
        }
        return async.forEach(files, handleFile, cb);
      };
      return async.series([
        ((cb) => {
          return this.mkdir(destDir,
        cb);
        }),
        (function(cb) {
          return fs.readdir(srcDir,
        function(err,
        files) {
            return handleFiles(err,
        files,
        cb);
          });
        })
      ], function(err) {
        if (callback) {
          return callback(err);
        }
      });
    }

  };

  module.exports = Generator;

}).call(this);

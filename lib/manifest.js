// Generated by CoffeeScript 2.5.1
(function() {
  var Manifest, ManifestFile, S, _, async, extractNameFromUri, fs, makeUriRelativeTo, marked, path, url;

  fs = require('fs');

  path = require('path');

  url = require('url');

  marked = require('marked');

  async = require('async');

  _ = require('underscore');

  S = require('string');

  // Extracts the name of the file without the extension

  // filename : Extracts only the name (without the extension) of a file
  extractNameFromUri = function(filename) {
    return path.basename(filename, path.extname(filename));
  };

  // Makes the uri relative to another one

  // uri        : A string representing an URI
  // relativeTo : The URI to make the first parameter relative to
  makeUriRelativeTo = function(uri, relativeTo) {
    if (uri.substr(0, 1) === '/') {
      return uri;
    } else {
      return path.join(relativeTo, uri);
    }
  };

  // Represents a file from a manifest
  ManifestFile = class ManifestFile {
    // Public: Creates a ManifestFile object from the specified uri

    // manifest : Manifest to which this file belongs
    // uri      : Location of the file
    // callback : A function that will be called with the ManifestFile object
    static load(manifest, uri, callback) {
      var f;
      f = new ManifestFile(manifest, uri);
      return f.refresh(function(err) {
        return callback(err, f);
      });
    }

    // Private: Creates a ManifestFile object

    // manifest : Manifest to which this file belongs
    // uri      : URI of the file
    // raw      : Content of the file
    constructor(manifest, uri1) {
      this.uri = uri1;
      this.manifest = manifest;
      this.slug = S(extractNameFromUri(this.uri)).slugify().s;
    }

    // Public: Refreshes the content

    // callback : A function that will be called once done
    refresh(callback = null) {
      return fs.readFile(this.uri, (err, data) => {
        if (err) {
          if (callback) {
            callback(err);
          }
          return;
        }
        this.raw = data.toString();
        this.render();
        return callback(null);
      });
    }

    // Public: Makes an uri relative to the uri for this file

    // uri   : A string
    makeRelativeUri(uri) {
      return makeUriRelativeTo(uri, path.dirname(this.uri));
    }

    // Private: Transforms markdown files to html, extracting
    // urls of relative image and adding anchor tags before all <h> tags
    render() {
      var content, convertToHtml, html, i, level, mdTitle, next_title_pos, remaining_content, slug, title, titles;
      this.assets = [];
      this.sections = [];
      this.html = '';
      convertToHtml = (markdown) => {
        var anchor, hTag, hTags, html, img, imgs, k, l, len, len1, new_img, ref, ref1, src, title;
        html = marked(markdown);
        imgs = html.match(/<img[^>]*>/gi);
        ref = imgs || [];
        for (k = 0, len = ref.length; k < len; k++) {
          img = ref[k];
          src = img.match(/src=("|')([^"']+)\1/i);
          if (src && !src[2].match(/^(https?):\/\//)) {
            if (!this.manifest.options.makeAssetsRelativeToGithub) {
              this.assets.push(src[2]);
            } else {
              url = 'https://github.com/' + this.manifest.options.makeAssetsRelativeToGithub + '/raw/master/' + src[2];
              new_img = img.replace(src[2], url);
              html = html.replace(img, new_img);
            }
          }
        }
        hTags = html.match(/<h([1-6])[^>]*>.+<\/h\1>/gi);
        ref1 = hTags || [];
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          hTag = ref1[l];
          title = hTag.substring(hTag.indexOf('>') + 1, hTag.lastIndexOf('<'));
          anchor = S(title).stripTags().decodeHTMLEntities().slugify().s;
          html = html.replace(hTag, '<a name="' + anchor + '"></a>' + hTag);
        }
        return html;
      };
      titles = this.raw.match(/^\#+ (.+)$/gm);
      remaining_content = this.raw;
      for (i in titles) {
        mdTitle = titles[i];
        i = parseInt(i);
        title = S(mdTitle).trim().replace(/\#*$/, '').trim().s;
        level = title.indexOf(' ');
        title = S(title).replace(/^\#+/, '').trim().s;
        if (i === 0) {
          this.title = title;
        }
        //string.js slugify removes all periods - marked.js converts periods to dashes
        // - override slugify function using marked.js regex (styson)
        //slug = S(title).slugify().s;
        slug = S(title).replace(/[^\w]+/g, '-').toLowerCase().dasherize().s;
        content = remaining_content.substr(remaining_content.indexOf(mdTitle));
        if (i < titles.length - 1) {
          next_title_pos = content.indexOf(titles[i + 1]);
          content = content.substr(0, next_title_pos);
          remaining_content = remaining_content.substr(next_title_pos);
        }
        html = convertToHtml(content);
        this.html += html;
        this.sections.push({
          slug: slug,
          level: level,
          title: title,
          markdown: content,
          html: html
        });
      }
      console.log(this.sections);
      if (this.sections.length === 0) {
        title = S(extractNameFromUri(this.uri)).humanize().s;
        slug = S(title).slugify().s;
        this.html = convertToHtml(this.raw);
        return this.sections.push({
          slug: slug,
          level: 1,
          title: title,
          markdown: this.raw,
          html: this.html
        });
      }
    }

  };

  // Represents a manifest

  // Stores all information from the manifest as well
  // as rendered files and the computed table of content
  Manifest = class Manifest {
    // Public: Creates a Manifest object reading the options from the given uri

    // uri       : The URI of a JSON-encoded file with the options
    // callback  : A function that will be called with the Manifest object
    static load(uri, callback) {
      var m;
      m = new Manifest({}, uri);
      return m.refresh(function(err) {
        return callback(err, m);
      });
    }

    // Public: Constructor

    // options   : An object with the manifest's options
    // uri       : The URI of the manifest
    constructor(options = {}, uri1 = null) {
      this.uri = uri1;
      this.files = [];
      this.setOptions(options);
    }

    // Public: Sets the options

    // options   : An object with the manifest's options
    setOptions(options) {
      var ref, ref1, ref2, ref3, ref4, ref5;
      this.title = (ref = options.title) != null ? ref : '';
      this.slug = S(this.title).slugify().s;
      this.category = (ref1 = options.category) != null ? ref1 : null;
      this.ignoreFirstFileForToc = options.home != null;
      this.maxTocLevel = (ref2 = options.maxTocLevel) != null ? ref2 : 2;
      this.makeAssetsRelativeToGithub = (ref3 = options.makeAssetsRelativeToGithub) != null ? ref3 : false;
      this.rootDir = (ref4 = options.rootDir) != null ? ref4 : '.';
      this.links = (ref5 = options.links) != null ? ref5 : [];
      return this.options = _.extend({}, options);
    }

    // Public: Adds files
    // The table of content will be rebuild

    // files     : An array of URIs
    // callback  : A function that will be called once all files are added
    addFiles(files, callback = null) {
      var d, i, k, lock, ref, results;
      lock = files.length;
      d = this.files.length;
      results = [];
      for (i = k = 0, ref = files.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
        results.push((() => {
          var j;
          j = d + i;
          return ManifestFile.load(this, this.makeRelativeUri(files[i]), (err, f) => {
            if (err) {
              lock = -1;
              if (callback) {
                callback(err);
              }
              return;
            }
            this.files[j] = f;
            if (--lock === 0) {
              this.buildTableOfContent();
              if (callback) {
                return callback(null);
              }
            }
          });
        })());
      }
      return results;
    }

    // Private: Builds the table of content from the <h> tags
    buildTableOfContent() {
      var currentLevel, entry, file, i, parentScopes, ref, results, scope, section;
      this.tableOfContent = [];
      scope = this.tableOfContent;
      parentScopes = [];
      currentLevel = 0;
      ref = this.files;
      results = [];
      for (i in ref) {
        file = ref[i];
        if (this.ignoreFirstFileForToc && i === '0') {
          continue;
        }
        results.push((function() {
          var k, len, ref1, results1;
          ref1 = file.sections;
          results1 = [];
          for (k = 0, len = ref1.length; k < len; k++) {
            section = ref1[k];
            if (section.level > this.maxTocLevel) {
              continue;
            }
            if (section.level <= currentLevel) {
              parentScopes = parentScopes.slice(0, parentScopes.length - (currentLevel - section.level));
              scope = parentScopes.pop();
            }
            entry = {
              slug: file.slug,
              title: section.title,
              anchor: section.slug,
              childs: []
            };
            scope.push(entry);
            parentScopes.push(scope);
            scope = entry.childs;
            results1.push(currentLevel = section.level);
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    // Public: Refreshes the manifest options and all files and rebuilds the table of content

    // callback : A function that will be called once done
    refresh(callback = null) {
      if (this.uri) {
        return fs.readFile(this.uri, (err, data) => {
          var files, options, ref;
          if (err) {
            return callback(err);
          }
          options = JSON.parse(data.toString());
          files = (ref = options.files) != null ? ref : [];
          if (options.home) {
            files.unshift(options.home);
          }
          this.files = [];
          this.setOptions(options);
          return this.addFiles(files, (err) => {
            if (err) {
              return callback(err);
            }
            return this.refreshFiles(callback);
          });
        });
      } else {
        return this.refreshFiles(callback);
      }
    }

    // Public: Refreshes all files and rebuilds the table of content

    // callback : A function that will be called once done
    refreshFiles(callback = null) {
      return async.forEach(this.files, (function(f, cb) {
        return f.refresh(cb);
      }), (err) => {
        if (err) {
          if (err) {
            callback(err);
          }
          return;
        }
        this.buildTableOfContent();
        if (callback) {
          return callback(null);
        }
      });
    }

    // Public: Makes an uri relative to this manifest's URI

    // uri : A string representing an URI
    makeRelativeUri(uri) {
      if (!this.uri) {
        return uri;
      }
      return makeUriRelativeTo(makeUriRelativeTo(uri, this.rootDir), path.dirname(this.uri));
    }

    // Watches all the associated files for changes

    // callback : A function that will be called whenever a files changes
    watch(callback) {
      var f, k, len, ref, results, watcher;
      watcher = (curr, prev) => {
        if (curr.mtime > prev.mtime) {
          return this.refresh(callback);
        }
      };
      if (this.uri) {
        fs.watchFile(this.uri, watcher);
      }
      ref = this.files;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        f = ref[k];
        results.push(fs.watchFile(f.uri, watcher));
      }
      return results;
    }

  };

  module.exports = Manifest;

}).call(this);
